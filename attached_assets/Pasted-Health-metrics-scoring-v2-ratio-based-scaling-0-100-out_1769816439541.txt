Health metrics scoring v2; ratio-based scaling, 0–100 output
Goal

Keep the player-facing Health Metric scores on a stable 0–100 scale across the whole campaign, while allowing building baselines and other modifiers to scale up massively in late game. Early decisions should still feel meaningful, even when raw production values grow by large factors.

What stays the same

Raw metric formulas remain unchanged; they still produce a multiplicative “raw factor”:

Living Standards (LS_raw) = baseline(Nutrition) × damp(Cleanliness) × damp(Crowding) × damp(Maintenance)

Productivity (PR_raw) = baseline(Drive) × damp(Fatigue) × damp(Noise) × damp(Crowding)

Partytime (PT_raw) = baseline(Fun) × damp(Fatigue) × (1 + NoiseBonus)

Baselines still come primarily from buildings, upgrades, policies, budgets, techs; dampeners and bonuses still come from primitives.

What changes

Previously, each health metric was “normalized to 1–100” directly from the raw calculation. That breaks once baselines scale a lot.

Now, we introduce a stage-scaled reference value, then score the ratio of raw performance vs reference, using a bounded curve.

New pipeline per metric

Compute raw metric factor

M_raw is one of LS_raw, PR_raw, PT_raw

Compute a reference target for the current commune stage

M_ref = ref0_M * (pop / pop0)^alpha_M * tierMult_M[tier]
Where:

pop is current resident count (or effective population, if you have that)

tier is commune progression tier (or similar stage variable)

ref0_M, pop0, alpha_M, tierMult_M[] are tunables

Compute ratio vs target

x = M_raw / M_ref

Convert ratio to a 0–100 score using Option A (power logistic)

score = 100 * (x^p_M) / (1 + x^p_M)

Clamp for safety

score = clamp(score, 0, 100)

If M_ref <= 0, treat as a config error and fall back to a safe default (eg. score = 50), or hard-fix with min ref.

Why this works

The game can scale raw values by 10×, 50×, 200×; the score remains readable and comparable.

Improvements feel consistent because the score reacts to multiplicative changes; a 20% upgrade matters at any stage.

“Decent” becomes a moving target defined by M_ref; as the commune grows, expectations rise.

Behaviour guarantees and intuition

If x = 1 (raw equals reference), score = 50

If x > 1, score trends toward 100

If x < 1, score trends toward 0

p_M controls sensitivity:

lower p = forgiving, flatter curve

higher p = more punishing below target, more rewarding above target

New tunables to add to dev tools / config

Per metric (LS, PR, PT):

p_M; curve sensitivity exponent

ref0_M; reference raw value at baseline population and tier

alpha_M; how strongly target scales with population

tierMult_M[tier]; per-tier scaling multiplier

Shared:

pop0; baseline population used for scaling

Optional, if you want hard guarantees that early game cannot hit extreme tiers:

tierScoreCap[tier]; clamps the max score by tier (eg. tier 1 cap 75, tier 2 cap 85, etc)

Or vibe-tier gating rules, eg. “Worldclass requires LS ≥ 90 and pop ≥ X and tier ≥ Y”

UI and downstream integration changes

Health metric UI stays 0–100; no UI redesign required.

Add an optional secondary line for debugging and player teaching:

“Target ratio: 1.15×” (that is x)

Any systems consuming metrics should use:

M_norm = score / 100 if they expect a 0–1 value

Implementation notes, edge cases

Ensure M_ref is never 0; use M_ref = max(M_ref, epsilon) where epsilon is small.

Avoid dampeners reaching exact 0 unless it’s a true “shutdown” state; otherwise one primitive can hard-zero a metric too often.

NoiseBonus: keep as-is, but ensure it cannot create negative PT multipliers; clamp (1 + NoiseBonus) to a sane range.
